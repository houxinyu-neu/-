# 进程和线程

## 进程和线程的区别

1. 根本上
   + 进程是资源分配的基本单位。
   + 线程是任务执行和调度的基本单位。

2. 开销
   + 进程拥有独立的代码段和数据空间，切换开销较大。
   + 线程共享代码段和数据空间，拥有自己独立的运行栈和程序计数器，切换开销较小。

3. 资源分配
   + 操作系统直接为进程分配资源。
   + 线程的资源来源于进程的分配。并共享同一进程所分配的资源。

4. 包含关系
   + 线程可以视作是粒度更小的进程。

## 进程之间通信

1. 管道

   在进程之间通过`read`和`write`进行通信。实质上开辟一块内核中的缓冲区，在缓冲区中缓冲消息的循环队列。

   + 无名管道`pipe`

     在父子进程之间通过`pipe`开启管道，使用`read`和`write`进行文件的读写。最后使用`close`可关闭管道。

   + 命名管道`fifo`

     不局限于父子进程，任何进程可`mkfifo`创建，相当于磁盘中的节点，任何进程均可访问。

2. 消息队列

   与管道相比，消息队列可以维持消息的特定格式和优先级，可以通过特定优先级与格式获取消息。

   常用操作与`msgsnd`发送消息、`msgrcv`接受消息、`msgget`打开消息队列。

3. 信号量

   + 进程间通过`signal`进行信号传递通信。
   + 对共享信号量`SV`，通过`P`（减一）和`V`（加一）控制共享内容的互斥。

4. 共享内存

   效率高，将共享存储区映射到各自进程的存储地址中。`shmget`

5. `socket`套接字。

   通过`socket`进行`bind`、`connect`、`listen`、`recv`。

6. 对比来看

消息队列和管道使用系统调用面向内核操作，进程通信需要四次拷贝。

+ 进程A的`buff`区到内核、内核到内存中、内存到内核中、内核到进程B的`buff`区。

+ 共享内存面向内存而言，只需要两次。从进程A的`buff`中到内存中、从内存中到进程B的`buff`区。

## 死锁

1. 死锁的概念

两个进程都在等待对方执行结束。

2. 死锁的原因

   资源竞争

   推进顺序非法

   ```javascript
   P1:require(P2)
   P2:require(P1)
   ```

3. 死锁的必要条件
   + 互斥。同一时刻只有一个进程执行。
   + 环路等待。有死锁必定成环。
   + 不可剥夺。进程在使用完毕前不可获取。
   + 请求保持。进程阻塞是不会被释放。

4. 避免死锁

   操作系统分配资源时对资源进行检测，若可能出现死锁将拒绝为其分配资源。