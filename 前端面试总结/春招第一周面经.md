# 前端实习生面经
大三前端一枚，2020.1放假起自学前端，历时两个月。

整理实习面试过程答得不好的部分。

## 第一周面经

第一周面了三家，都给了`offer`，都比较基础，把问题发出来大家共同学习。

其中回答的不好加粗标记，在后面整理出来。

#### 广联达

时间：2020.3.6 

时长：1h20min

面试体验：人生第一场面试，幸运通过，**感谢面试的小哥，给了我很大的鼓励！！**
2020.3.18 拿到offer，HR小姐姐好好，说如果有更好的选择提前跟她说就行，真好~

1. 自我介绍
2. 块级元素、行内元素、空元素
3. H5新增
4. CSS选择器和权重值
5. 清除浮动
6. **`display`能取到哪些值？**
7. `position`中各个值的区别？
8. CSS3新增
9. **浏览器兼容了解多少**
10. 原型链
11. 继承
12. 闭包
13. `Vue`生命周期
14. **`MVVM`的理解**
15. **`Vue`的常见指令**
16. `Vue`之间组件传值
17. **`VueX`了解多少**

#### 蓦然认知一面

时间：2020.3.17 	

时长：57min

面试体验：人生第二场面试，全场手写代码，面试体验很棒，幸运通过。

1. 自我介绍
2. 原型链
3. 手写原型链继承
4. **手写`bind`方法**
5. 事件循环机制
6. 手撕数组去重
7. **手撕双向绑定**
8. **手撕发布-订阅者模式**
9. 手撕防抖
10. `HTTP`状态码
11. 跨域
12. **表单能否跨域**
13. BFC
14. 水平垂直居中
15. **`canvas`常用`API`**
16. **`CSS3`的动画**

#### 蓦然认知二面

时间：2020.3.20

时长：50min

面试体验：依旧全场手撕代码

1. 字符串转化

   将一个字符串`str="2[a]3[b ]"`转换为`"aabbb"`

2. 数组扁平化

3. 实现阶乘

   `5！ = 5*4*3*2*1`

4. 浮点数运算

5. 过滤`undefined`和`null`的参数

#### 经纬恒润

时间：2020.3.19

时长：26min

面试体验：面试官迟到了一个点。。。。

1. 自我介绍
2. 说项目
3. `Vue`生命周期
4. **哪个生命周期中`el`有值**
5. 双向绑定
6. **`computer`和`watch`的原理**
7. 闭包
8. 事件执行机制

## 第一周面经整理

1. `flex`布局

   `flex`作为CSS3新增弹性盒子。

   ```css
   box {
       display:flex;
       display:inline-flex;
       display:-webkit-flex;   
   }
   ```

   + 常见属性

     ```css
     flex-flow:row nowrap	//行排序，不换行
     flex-flow:column wrap 	// 列排序，换行
     justify-content:flex-start|flex-end|center|space-around|space-between	//水平布局
     align-items:flex-start|flex-end|center|strench|baseline					//垂直布局
     order:-1|0				//顺序
     flex:none|[<flex-grow><flex-shrink>|<flex-basic>]		//允许方法、允许缩小、基准
     ```

2. 常见浏览器兼容

   ​	**HTML兼容**

   + HTML在IE9以下不兼容，需要从外引入HTML5。

     ```html
     <!--[if It Ie 9]>
     <script src="html5shiv.js"></script>
     <![endif]-->		
     ```

   + 部分浏览器中`img`中间有空隙，需要设置`float`。

     **CSS兼容**

   + CSS上`min-height`不生效，手动设置`height`。

     ```css
     {
         min-height:200px;
         height:200px;
         overflow:hidden;
         height:auto !important;
     }
     ```

   + 不同浏览器的`margin`和`padding`默认值不同，需要在`body`和`html`中预设。

     **JavaScript兼容**

   + 事件绑定的兼容`addEventListener()`和IE中的`attachEvent()`

   + 原生`Ajax`的创建时`XMLHttpRequest()`和IE中的`activeXObject()`

   + 求窗口大小的兼容性

     ```javascript
     //可视区大小 (content+padding)
     let width = document.documentElement.clientWidth||document.body.clientWidth
     //元素大小 (content+padding+border)
     let width = document.documentElement.offsetWidth||document.body.offsetWidth
     //实际大小
     let width = document.documentElement.scrollWidth||document.body.scrollWidth
     ```

     **浏览器的`hack`**

   + IE条件注释

     ```html
     <!--[if It IE ]>
     <![endif]-->
     ```

   + IE6的`*`或`_`，IE7的`*`

3. 谈谈`MVVM`的理解

   `MVVM`模型分为`Model`层、`View`层、`ViewModel`层。

   `Model`层用`JavaScript`对象表示，`View`层负责显示，两者通过`ViewModel`相耦合。

   开发者将注重`Model`也就是数据，而减少对复杂`DOM`的操作。

4. 手写`Vue.js`双向绑定

   `Vue`通过数据劫持和发布-订阅者模式相结合的方式，实现双向绑定。

   具体上通过`Object.defineProperty()`来规定`setter`和`getter`属性进行数据劫持。再通过订阅者`watcher`对数据进行依赖收集。当数据改变时通知订阅者，触发回调函数，更新视图。

   

5. 手写发布-订阅者模式

   发布-订阅者模式。可以理解成发布者将订阅事件保存在缓存队列中，订阅者通过事件的监听、触发与移除触发相应的回调函数。

   ```javaScript
   /**2020.3.19
    * 手写发布-订阅者模式
    */
   class EventEmitter {
     // 存储事件缓存队列
     constructor() {
       this.events = {}
     }
     // 绑定事件
     on(event, callback) {
       if (!this.events[event]) {
         this.events[event] = [callback]
       } else {
         this.events[event].push(callback)
       }
     }
     // 事件触发
     emit(event) {
       this.events[event] && this.events[event].forEach(cb => cb())
     }
     // 事件的移除
     remove(event, callback) {
       if (this.events[event]) {
         this.events =  this.events[event].filter(cb => cb !== callback)
       }
     }
   }
   let em = new EventEmitter()
   function foo() {
     console.log("Work!")
   }
   em.on("work", foo)
   em.remove("work", foo)
   em.emit("work")
   ```

6. `vue`常见指令

   `v-if`，`v-else`,`v-else-if`,`v-show`，`v-for`。

   `v-on`,`v-bind`,`v-model`。

   `v-once`只进行单次渲染，后续不再更新。

7. 跨域相关

   ​	浏览器处于安全考虑，存在同源策略`SOP`。相同协议、相同域名、相同端口号间进程可Ajax通信。

   ​	不收跨域影响的标签：`script`,`link`,`img`,`form`。

   + `JSONP`

     填充式的`JSON`，在`script`标签请求地并返回回调函数，实现跨域。

     缺陷在于，只能实现`get`请求。

     ```javascript
     <script src="url/?callback=getRes"></script>
     function getRes(res){
         //return res
         //实现跨域请求
     }
     ```

   + `CORS`

     服务端配合实现跨域。

     `Cross-Origin-Resourse-Sharing`跨域资源共享。

     ```javascript
     //前端
     let xhr = new XMLHttpRequest()//现代浏览器
     xhr.withCredentials =true//前端原生Ajax携带域下的cookie
     axios.defaults.withCredentials = true//axios携带cookie
     ```

     ```javascript
     //后端
     response.setHeaders("Access-Control-Allow-Origin","url")
     response.setHeaders("Access-Control-Allow-Credentials",true)
     ```

   + H5的`postMessage(data,url)`

     ```javascript
     window.postMessage(JSON.Stringify(data),"url")
     window.addEventListener("message",function(){
         //跨域接收
     })
     ```

   + H5新增的`webSocket`

     基于TCP的持久化全双共协议实现跨域。

     ```javascript
     let webS = new WebSocket(url,[protocal])
     webS.send()
     wenS.onmessage()
     webS.close()
     ```

   + `iframe`+`document.domain`

     父域使用`iframe`将子域引入，再使用`document.domain`设置基础域名相同。

     ```html
     //父域
     <iframe src=""></iframe>
     <script>
     	domain.name = ""
     </script>
     //子域
     <script>
         domain.name = ""
     </script>
     ```

   + `iframe`+`window.name`

     `window.name`在不同域下均有效。

   + `Proxy`反向代理

     利用同源策略限制浏览器，而非`HTTP`协议。

     - 配置`Nginx`作为跳板，反向代理`domin2`的接口。

     - 使用`Node.js`中的`http-proxy-middleware`进行代理。
     - 配置`Vue`的`config`配置实现代理跨域的接口。

8. `Promise`，`Generator`，`async`和`await`

9. 手写`Promise`

10. 手写继承

    + 构造函数继承

      子类中通过`call`或者`apply`调用父类的构造函数。但缺陷在于方法会重定义，不可复用。

      ```javascript
      // 构造函数继承
      function Father(name) {
        this.name = name
        this.sayName = function () {
          console.log(name)
        }
      }
      function Son(name) {
        Father.call(this, name)
      }
      let i = new Son("Bob")
      let j = new Son("Bob")
      console.log(i.sayName === j.sayName)//false
      ```

    + 原型继承

      子类的原型指向父类的实例。缺陷在于引用类型将会被共享，且定义一个子类时不能够向父类传递参数。

      ```javascript
      // 原型链继承
      function Father() {
        this.age = [0, 1, 2]
      }
      Father.prototype.sayName = function () {
        console.log(this.age)
      }
      
      function Son() {
      
      }
      Son.prototype = new Father()
      let instance1 = new Son()
      let instance2 = new Son()
      instance2.age.push(0)
      instance2.sayName()//[0,1,2,0]
      instance1.sayName()//[0,1,2,0]
      ```

      *注意：`push`只改变内存堆的值不改变内存栈中的地址。而`=`将为数组重新赋新的内存栈地址。*

    + 组合继承

      构造函数+原型继承。构造函数继承实例属性，原型继承共享属性和方法。缺点在于调用两次父类的构造函数。

      ```javascript
      // 组合继承
      function Father() {
      
      }
      Son.prototype = new Father()//第一次
      
      function Son() {
        Father.call(this)//第二次
      }
      ```

    + 原型式继承`Object.create()`

      利用构造函数，传入一个对象，让该对象等于构造函数的原型，返回出构造函数的实例。相当于进行一次浅拷贝。缺点在于俩对象间的共享。

      ```javascript
      function Object.create(obj){
          function F(){}
          F.prototype = obj
          return new F()
      }
      ```

    + 寄生组合继承

      利用原型式继承得到超类实例的副本，将该副本指向子类的原型。**最好的继承方法**

      ```javascript
      function Object.create(obj){
      	function F(){}
      	F.prototype = obj
      	return new F()
      }
      function inherit(Son,Father){
      	let sonPrototype = Object.create(Father)
      	Son.prototype = sonPrototype
      	sonPrototype.constructor = Son
      }
      ```

    + ES6的`extend`

11. 文件如何上传的

12. 各大浏览器的内核

    ```css
    Mozilla内核(firefox)			-moz
    Webkit内核(Chrome,Safari)		-webkit
    Blink内核(Chrome,Opera)		
    Trident内核(IE浏览器)		  -ms
    ```

    