# `leetcode`刷题之旅

`leetcode`是个好东西。

算法就像内功，越扎实走的也就越远。

## 第一天

1. 两数之和

> 给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。
>
> 你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。
>
> 示例:
>
> 给定 nums = [2, 7, 11, 15], target = 9
>
> 因为 nums[0] + nums[1] = 2 + 7 = 9
>
> 所以返回 [0, 1]

思路：暴力求解的时间复杂度过高，将达到`O(n)=n²`。采取另一种方式，声明额外的数组，存储目标的差值，用额外的数组的空间来换取时间。

```javascript
function twoSum(nums, target) {
  if (!Array.isArray(nums)) throw ("Array")
  let temp = [],
    tempIndex = 0
  nums.forEach(item => {
    temp[tempIndex++] = target - item
  })
  for (let i = 0; i < nums.length; i++) {
    if (temp.indexOf(nums[i]) !== -1 && temp.indexOf(nums[i]) !== i) {
      return [i, temp.indexOf(nums[i])]
    }
  }
}
```

2. 比特位计数

> 给定一个非负整数 num。对于 0 ≤ i ≤ num 范围中的每个数字 i ，计算其二进制数中的 1 的数目并将它们作为数组返回。
>
> 示例 1:
>
> 输入: 2
> 输出: [0,1,1]
> 示例 2:
>
> 输入: 5
> 输出: [0,1,1,2,1,2]

思路：动态规划。找到状态转移方程。

要获取二进制的值，可分成奇数和偶数来考虑。

对于奇数，二进制是前一数加上一。

对于偶数，始终等于`2*dp[i/2]`

```javascript
function countBits(num) {
  if (typeof (num) !== "number") throw ("Not a Number")
  if (num === 0) return [0]
  if (num === 1) return [0, 1]
  let dp = new Array(num + 1)
  dp[0] = 0, dp[1] = 1
  for (let i = 2; i <= num; i++) {
    if (i % 2 === 0) {
      dp[i] = dp[i / 2]
    } else {
      dp[i] = dp[i - 1] + 1
    }
  }
  return dp
}
```

3. 零钱兑换

> 给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。
>
> 示例 1:
>
> 输入: coins = [1, 2, 5], amount = 11
> 输出: 3 
> 解释: 11 = 5 + 5 + 1
> 示例 2:
>
> 输入: coins = [2], amount = 3
> 输出: -1

思路：经典的动态规划。找到状态转义方程`dp[n] = dp[n-coin] + 1 `

```javascript
var coinChange = function(coins, amount) {
let dp = new Array(amount+1).fill(Infinity)
    dp[0] = 0
    for(let i = 1;i<=amount;i++){
        for(let coin of coins){
            if( i >= coin ){
                dp[i] = Math.min(dp[i],dp[i-coin]+1)
            }
        }
    }
    return dp[amount] === Infinity ? -1 : dp[amount]
};
```

